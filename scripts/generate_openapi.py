#!/usr/bin/env python3
import json
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
SPEC_PATH = ROOT / 'schema' / 'openapi.json'
OUT_DIR = ROOT / 'src' / 'generated'


def ts_type(schema):
    if not schema:
        return 'unknown'
    if '$ref' in schema:
        return schema['$ref'].split('/')[-1]
    if 'anyOf' in schema:
        variants = [ts_type(v) for v in schema['anyOf']]
        return ' | '.join(dict.fromkeys(variants))
    t = schema.get('type')
    if t == 'string':
        return 'string'
    if t in ('integer', 'number'):
        return 'number'
    if t == 'boolean':
        return 'boolean'
    if t == 'array':
        return f"{ts_type(schema.get('items', {}))}[]"
    if t == 'object':
        props = schema.get('properties', {})
        if not props:
            return 'Record<string, unknown>'
        req = set(schema.get('required', []))
        lines = ['{']
        for key, value in props.items():
            opt = '' if key in req else '?'
            lines.append(f'  {key}{opt}: {ts_type(value)};')
        lines.append('}')
        return '\n'.join(lines)
    return 'unknown'


def qualify_client_type(type_name: str) -> str:
    primitives = {'string', 'number', 'boolean', 'unknown', 'void', 'null', 'Record<string, unknown>'}
    if type_name in primitives:
        return type_name
    if type_name.endswith('[]'):
        inner = type_name[:-2]
        return f'{qualify_client_type(inner)}[]'
    if '|' in type_name:
        return ' | '.join(qualify_client_type(part.strip()) for part in type_name.split('|'))
    return f'API.{type_name}'


def schema_to_client_type(schema):
    if not schema:
        return 'void'
    if '$ref' in schema:
        return qualify_client_type(ts_type(schema))
    if schema.get('type') == 'array':
        return qualify_client_type(ts_type(schema))
    if schema.get('type') in ('string', 'number', 'integer', 'boolean'):
        return qualify_client_type(ts_type(schema))
    if 'anyOf' in schema:
        return qualify_client_type(ts_type(schema))
    return 'unknown'


def generate_types(spec):
    schemas = spec.get('components', {}).get('schemas', {})
    lines = [
        '// AUTO-GENERATED FILE. DO NOT EDIT.',
        '// Generated by scripts/generate_openapi.py from schema/openapi.json',
        ''
    ]
    for name in sorted(schemas):
        schema = schemas[name]
        if schema.get('type') == 'object' or schema.get('properties'):
            lines.append(f'export interface {name} ' + '{')
            req = set(schema.get('required', []))
            for key, value in schema.get('properties', {}).items():
                opt = '' if key in req else '?'
                lines.append(f'  {key}{opt}: {ts_type(value)};')
            lines.append('}')
            lines.append('')
        else:
            lines.append(f'export type {name} = {ts_type(schema)};')
            lines.append('')
    return '\n'.join(lines).rstrip() + '\n'


def op_name(method, path, operation):
    return operation.get('operationId') or f"{method}_{path.strip('/').replace('/', '_').replace('{', '').replace('}', '')}"


def path_to_template(path):
    out, i = '', 0
    while i < len(path):
        if path[i] == '{':
            j = path.index('}', i)
            name = path[i + 1:j]
            out += '${params.' + name + '}'
            i = j + 1
        else:
            out += path[i]
            i += 1
    return out


def response_type(operation):
    responses = operation.get('responses', {})
    for code in ['200', '201', '202']:
        if code in responses:
            schema = responses[code].get('content', {}).get('application/json', {}).get('schema')
            return schema_to_client_type(schema)
    return 'void'


def request_type(operation):
    schema = operation.get('requestBody', {}).get('content', {}).get('application/json', {}).get('schema')
    if not schema:
        return None
    return schema_to_client_type(schema)


def generate_client(spec):
    lines = [
        '// AUTO-GENERATED FILE. DO NOT EDIT.',
        '// Generated by scripts/generate_openapi.py from schema/openapi.json',
        '',
        "import type * as API from './types';",
        '',
        "const DEFAULT_API_BASE_URL = 'http://localhost:8000';",
        '',
        'export function createApiClient(baseUrl = import.meta.env.VITE_API_BASE_URL || DEFAULT_API_BASE_URL) {',
        '  const normalizedBase = baseUrl.replace(/\\/$/, "");',
        '  async function request<T>(path: string, init?: RequestInit): Promise<T> {',
        '    const response = await fetch(`${normalizedBase}${path}`, {',
        "      headers: { 'Content-Type': 'application/json', ...(init?.headers || {}) },",
        '      ...init',
        '    });',
        '    if (!response.ok) throw new Error(`Request failed: ${response.status}`);',
        '    if (response.status === 204) return undefined as T;',
        '    return response.json() as Promise<T>;',
        '  }',
        '',
        '  return {'
    ]

    for path in sorted(spec['paths']):
        for method in sorted(spec['paths'][path]):
            if method.startswith('x-'):
                continue
            op = spec['paths'][path][method]
            name = op_name(method, path, op)
            path_params = [p for p in op.get('parameters', []) if p.get('in') == 'path']
            req_t = request_type(op)
            resp_t = response_type(op)

            params_sig = []
            if path_params:
                params_sig.append('params: { ' + ', '.join(f"{p['name']}: string" for p in path_params) + ' }')
            if req_t:
                params_sig.append(f'body: {req_t}')

            lines.append(f"    async {name}({', '.join(params_sig)}): Promise<{resp_t}>" + ' {')
            path_literal = f'`{path_to_template(path)}`' if path_params else f"'{path}'"
            request_init = [f"method: '{method.upper()}'"]
            if req_t:
                request_init.append('body: JSON.stringify(body)')
            lines.append(f"      return request<{resp_t}>({path_literal}, {{ {', '.join(request_init)} }});")
            lines.append('    },')

    lines += ['  };', '}', '']
    return '\n'.join(lines)


def default_fixture(schema):
    if not schema:
        return None
    if '$ref' in schema:
        return None
    if 'anyOf' in schema:
        return default_fixture(schema['anyOf'][0])
    t = schema.get('type')
    if t == 'string':
        return schema.get('example', 'example')
    if t in ('number', 'integer'):
        return schema.get('example', 0)
    if t == 'boolean':
        return schema.get('example', False)
    if t == 'array':
        return [default_fixture(schema.get('items', {}))]
    if t == 'object':
        return {k: default_fixture(v) for k, v in schema.get('properties', {}).items()}
    return None


def generate_fixtures(spec):
    schemas = spec.get('components', {}).get('schemas', {})
    lines = [
        '// AUTO-GENERATED FILE. DO NOT EDIT.',
        '// Generated by scripts/generate_openapi.py from schema/openapi.json',
        '',
        "import type * as API from './types';",
        ''
    ]
    for name in sorted(schemas):
        const_name = name[0].lower() + name[1:] + 'Fixture'
        payload = json.dumps(default_fixture(schemas[name]), indent=2)
        lines.append(f'export const {const_name}: API.{name} = {payload} as API.{name};')
        lines.append('')
    return '\n'.join(lines)


def generate_msw(spec):
    lines = [
        '// AUTO-GENERATED FILE. DO NOT EDIT.',
        '// Generated by scripts/generate_openapi.py from schema/openapi.json',
        '',
        "import { http, HttpResponse } from 'msw';",
        "import * as fixtures from './fixtures';",
        '',
        'export const generatedHandlers = ['
    ]
    for path in sorted(spec['paths']):
        for method in sorted(spec['paths'][path]):
            if method.startswith('x-'):
                continue
            op = spec['paths'][path][method]
            resp_t = response_type(op)
            msw_path = path.replace('{', ':').replace('}', '')
            if resp_t.startswith('API.'):
                is_array = resp_t.endswith('[]')
                raw = resp_t.replace('API.', '').replace('[]', '')
                fixture_name = raw[0].lower() + raw[1:] + 'Fixture'
                body = f'[fixtures.{fixture_name}]' if is_array else f'fixtures.{fixture_name}'
                lines.append(f"  http.{method}('{msw_path}', () => HttpResponse.json({body})),")
            else:
                lines.append(f"  http.{method}('{msw_path}', () => new HttpResponse(null, {{ status: 204 }})),")
    lines += ['];', '']
    return '\n'.join(lines)


def main():
    spec = json.loads(SPEC_PATH.read_text())
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    (OUT_DIR / 'types.ts').write_text(generate_types(spec))
    (OUT_DIR / 'apiClient.ts').write_text(generate_client(spec))
    (OUT_DIR / 'fixtures.ts').write_text(generate_fixtures(spec))
    (OUT_DIR / 'mswHandlers.ts').write_text(generate_msw(spec))
    print('Generated OpenAPI artifacts in src/generated')


if __name__ == '__main__':
    main()
